import { writeFileSync, mkdirSync, existsSync } from 'node:fs'
import { dirname } from 'node:path'
import type { GenTsPluginOptions } from './types.ts'
import type { SafenvContext, SafenvVariable, SafenvPlugin } from '../types.ts'

/**
 * Generate TypeScript validation code with multiple output modes
 * @param options Plugin configuration options
 * @returns SafenvPlugin instance
 */
export function genTsPlugin(options: GenTsPluginOptions): SafenvPlugin {
  return {
    name: 'genTsPlugin',
    tags: ['typescript', 'generator'],

    async afterGenerate(context: SafenvContext): Promise<void> {
      const content = generateTypeScriptContent(context, options)
      writeFile(options.outputPath, content)

      this.debug(`Generated TypeScript file: ${options.outputPath}`, {
        validatorStyle: options.validatorStyle,
        exportMode: options.exportMode,
        linesGenerated: content.split('\n').length,
      })

      console.log(
        `âœ… genTsPlugin: Generated TypeScript file at ${options.outputPath}`
      )
    },

    async cleanup(): Promise<void> {
      // Cleanup logic if needed
    },
  }
}

// Helper function to ensure directory exists and write file
function writeFile(filePath: string, content: string): void {
  const dir = dirname(filePath)
  if (!existsSync(dir)) {
    mkdirSync(dir, { recursive: true })
  }
  writeFileSync(filePath, content, 'utf8')
}

/**
 * Generate TypeScript content based on validator style and export mode
 */
function generateTypeScriptContent(
  context: SafenvContext,
  options: GenTsPluginOptions
): string {
  const parts: string[] = []

  // Add file header
  parts.push(generateFileHeader(context, options))

  // Generate imports based on validator style
  const imports = generateImports(context, options)
  if (imports) {
    parts.push(imports)
  }

  // Generate TypeScript interface
  parts.push(generateTypeInterface(context, options))

  // Generate validator based on style
  if (options.validatorStyle !== 'none') {
    parts.push(generateValidator(context, options))
  }

  // Generate exports based on export mode
  if (options.exportMode) {
    parts.push(generateExportCode(context, options))
  }

  return parts.filter(Boolean).join('\n\n')
}

/**
 * Generate file header with metadata
 */
function generateFileHeader(
  context: SafenvContext,
  options: GenTsPluginOptions
): string {
  const timestamp = new Date().toISOString()
  return `// Generated by @dweb-cloud/safenv - GenTsPlugin
// Config: ${context.config.name || 'unnamed'}
// Validator Style: ${options.validatorStyle}
// Export Mode: ${options.exportMode || 'none'}
// Generated at: ${timestamp}
// DO NOT EDIT - This file is auto-generated`
}

/**
 * Generate imports based on validator style and export mode
 */
function generateImports(
  context: SafenvContext,
  options: GenTsPluginOptions
): string {
  const imports: string[] = []

  // Import based on validator style
  switch (options.validatorStyle) {
    case 'zod':
      // Use selective imports for tree-shaking
      const zodTypes = getRequiredZodTypes(context.config.variables)
      imports.push(`import { ${zodTypes.join(', ')} } from 'zod'`)
      imports.push(`const z = { ${zodTypes.join(', ')} }`)
      break

    case 'pure':
      // No external imports needed for pure validation
      break

    default:
      // No validator imports
      break
  }

  // Import based on export mode
  switch (options.exportMode) {
    case 'env-file':
    case 'json-file':
    case 'yaml-file':
    case 'toml-file':
      imports.push(`import { readFileSync, existsSync } from 'node:fs'`)
      imports.push(`import { resolve } from 'node:path'`)

      // Additional imports for file formats
      if (options.exportMode === 'yaml-file') {
        imports.push(`import { load as yamlLoad } from 'js-yaml'`)
      } else if (options.exportMode === 'toml-file') {
        imports.push(`import { parse as tomlParse } from '@iarna/toml'`)
      }
      break
  }

  return imports.length > 0 ? imports.join('\n') : ''
}

/**
 * Get required Zod types for tree-shaking
 */
function getRequiredZodTypes(
  variables: Record<string, SafenvVariable>
): string[] {
  const types = new Set<string>()

  Object.values(variables).forEach(variable => {
    switch (variable.type) {
      case 'string':
        types.add('string')
        break
      case 'number':
        types.add('number')
        break
      case 'boolean':
        types.add('boolean')
        break
      case 'array':
        types.add('array')
        types.add('string') // for parsing comma-separated strings
        break
      case 'object':
        types.add('object')
        types.add('string') // for parsing JSON strings
        break
    }
  })

  types.add('object') // Always needed for the main schema
  return Array.from(types)
}

/**
 * Generate TypeScript interface
 */
function generateTypeInterface(
  context: SafenvContext,
  _options: GenTsPluginOptions
): string {
  const configName = context.config.name || 'Config'
  const interfaceName = toPascalCase(configName) + 'Variables'

  const fields: string[] = []

  Object.entries(context.config.variables).forEach(([key, variable]) => {
    const optional = !variable.required ? '?' : ''
    const tsType = getTypeScriptType(variable)
    const comment = variable.description
      ? `  /** ${variable.description} */\n`
      : ''
    fields.push(`${comment}  ${key}${optional}: ${tsType}`)
  })

  return `/**
 * TypeScript interface for ${configName} environment variables
 */
export interface ${interfaceName} {
${fields.join('\n')}
}`
}

/**
 * Generate validator based on style
 */
function generateValidator(
  context: SafenvContext,
  options: GenTsPluginOptions
): string {
  const configName = context.config.name || 'Config'
  const validatorName =
    options.validatorName || `${toCamelCase(configName)}Schema`

  switch (options.validatorStyle) {
    case 'zod':
      return generateZodValidator(context, validatorName, options)
    case 'pure':
      return generatePureValidator(context, validatorName, options)
    default:
      return ''
  }
}

/**
 * Generate Zod-style validator with tree-shaking imports
 */
function generateZodValidator(
  context: SafenvContext,
  validatorName: string,
  options: GenTsPluginOptions
): string {
  const zodFields: string[] = []

  Object.entries(context.config.variables).forEach(([key, variable]) => {
    const zodType = getZodType(variable)
    const defaultValue =
      variable.default !== undefined
        ? `.default(${JSON.stringify(variable.default)})`
        : ''
    const optional = !variable.required ? '.optional()' : ''

    zodFields.push(`  ${key}: z.${zodType}${defaultValue}${optional}`)
  })

  const exportPrefix = options.exportValidator !== false ? 'export ' : ''

  return `/**
 * Zod schema for ${context.config.name || 'config'} validation
 * Uses selective imports for optimal tree-shaking
 */
${exportPrefix}const ${validatorName} = z.object({
${zodFields.join(',\n')}
})`
}

/**
 * Generate pure TypeScript validator (no dependencies)
 */
function generatePureValidator(
  context: SafenvContext,
  validatorName: string,
  options: GenTsPluginOptions
): string {
  const validationFunctions = generatePureValidationFunctions(
    context.config.variables
  )
  const validatorInterface =
    toPascalCase(context.config.name || 'Config') + 'Variables'

  const exportPrefix = options.exportValidator !== false ? 'export ' : ''

  return `/**
 * Pure TypeScript validation functions (no external dependencies)
 */
${validationFunctions}

/**
 * Main validator function
 */
${exportPrefix}const ${validatorName} = {
  parse: (input: Record<string, unknown>): ${validatorInterface} => {
    const result: Partial<${validatorInterface}> = {}
    const errors: string[] = []
    
    ${generatePureValidationLogic(context.config.variables)}
    
    if (errors.length > 0) {
      throw new Error(\`Validation failed: \${errors.join(', ')}\`)
    }
    
    return result as ${validatorInterface}
  }
}`
}

/**
 * Generate export code based on export mode
 */
function generateExportCode(
  context: SafenvContext,
  options: GenTsPluginOptions
): string {
  const configName = context.config.name || 'config'
  const exportName = options.exportName || toCamelCase(configName)
  const validatorName =
    options.validatorName || `${toCamelCase(configName)}Schema`

  switch (options.exportMode) {
    case 'process.env':
      return generateProcessEnvExport(exportName, validatorName, options)

    case 'process.env-static':
      return generateStaticProcessEnvExport(context, exportName, options)

    case 'env-file':
      return generateEnvFileExport(
        configName,
        exportName,
        validatorName,
        options
      )

    case 'json-file':
      return generateJsonFileExport(
        configName,
        exportName,
        validatorName,
        options
      )

    case 'yaml-file':
      return generateYamlFileExport(
        configName,
        exportName,
        validatorName,
        options
      )

    case 'toml-file':
      return generateTomlFileExport(
        configName,
        exportName,
        validatorName,
        options
      )

    default:
      return ''
  }
}

/**
 * Generate process.env export
 */
function generateProcessEnvExport(
  exportName: string,
  validatorName: string,
  _options: GenTsPluginOptions
): string {
  return `/**
 * Parsed and validated environment variables from process.env
 */
export const ${exportName} = ${validatorName}.parse(process.env)`
}

/**
 * Generate static process.env export (tree-shakeable)
 */
function generateStaticProcessEnvExport(
  context: SafenvContext,
  exportName: string,
  options: GenTsPluginOptions
): string {
  const prefix = exportName.toUpperCase()
  const exports: string[] = []

  Object.entries(context.config.variables).forEach(([key, variable]) => {
    const variableName = `${prefix}_${key}`
    const zodType =
      options.validatorStyle === 'zod'
        ? `z.${getZodType(variable)}`
        : 'parseValue'
    const comment = variable.description
      ? `/** ${variable.description} */\n`
      : ''

    exports.push(
      `${comment}export const ${variableName} = /* @__PURE__ */ ${zodType}.parse(process.env.${key})`
    )
  })

  return exports.join('\n\n')
}

/**
 * Generate env file loading export
 */
function generateEnvFileExport(
  configName: string,
  exportName: string,
  validatorName: string,
  options: GenTsPluginOptions
): string {
  const envFilePath = options.envFilePath || `${configName}.safenv.env`

  return `/**
 * Load configuration from .env file
 */
const envFile = resolve(import.meta.dirname, '${envFilePath}')

// Load environment file if it exists
if (existsSync(envFile)) {
  // Use Node.js built-in loadEnvFile if available (Node 20.6+)
  if (process.loadEnvFile) {
    process.loadEnvFile(envFile)
  } else {
    // Fallback: manual .env parsing
    const envContent = readFileSync(envFile, 'utf-8')
    envContent.split('\\n').forEach(line => {
      const [key, ...valueParts] = line.trim().split('=')
      if (key && valueParts.length > 0) {
        process.env[key] = valueParts.join('=')
      }
    })
  }
}

export const ${exportName} = ${validatorName}.parse(process.env)`
}

/**
 * Generate JSON file loading export
 */
function generateJsonFileExport(
  configName: string,
  exportName: string,
  validatorName: string,
  options: GenTsPluginOptions
): string {
  const jsonFilePath = `${configName}.safenv.json`
  const customDeps = options.customDeps || []
  const customInject = options.customInjectCode || []

  // Handle custom JSON parser (e.g., json5, jsonc)
  const jsonParser = customDeps.includes('json5') ? 'JSON5' : 'JSON'
  const parseFunction = `${jsonParser}.parse`

  let customImports = ''
  if (customInject.length > 0) {
    customImports = '\n' + customInject.join('\n') + '\n'
  }

  return `${customImports}/**
 * Load configuration from JSON file
 */
const jsonFile = resolve(import.meta.dirname, '${jsonFilePath}')
let jsonData = {}

if (existsSync(jsonFile)) {
  const jsonContent = readFileSync(jsonFile, 'utf-8')
  jsonData = ${parseFunction}(jsonContent)
}

export const ${exportName} = ${validatorName}.parse(jsonData)`
}

/**
 * Generate YAML file loading export
 */
function generateYamlFileExport(
  configName: string,
  exportName: string,
  validatorName: string,
  _options: GenTsPluginOptions
): string {
  const yamlFilePath = `${configName}.safenv.yaml`

  return `/**
 * Load configuration from YAML file
 */
const yamlFile = resolve(import.meta.dirname, '${yamlFilePath}')
let yamlData = {}

if (existsSync(yamlFile)) {
  const yamlContent = readFileSync(yamlFile, 'utf-8')
  yamlData = yamlLoad(yamlContent) as Record<string, unknown>
}

export const ${exportName} = ${validatorName}.parse(yamlData)`
}

/**
 * Generate TOML file loading export
 */
function generateTomlFileExport(
  configName: string,
  exportName: string,
  validatorName: string,
  _options: GenTsPluginOptions
): string {
  const tomlFilePath = `${configName}.safenv.toml`

  return `/**
 * Load configuration from TOML file
 */
const tomlFile = resolve(import.meta.dirname, '${tomlFilePath}')
let tomlData = {}

if (existsSync(tomlFile)) {
  const tomlContent = readFileSync(tomlFile, 'utf-8')
  tomlData = tomlParse(tomlContent)
}

export const ${exportName} = ${validatorName}.parse(tomlData)`
}

// Utility functions
function toPascalCase(str: string): string {
  return str
    .replace(/[-_\s]+(.)?/g, (_, char) => (char ? char.toUpperCase() : ''))
    .replace(/^./, char => char.toUpperCase())
}

function toCamelCase(str: string): string {
  return str
    .replace(/[-_\s]+(.)?/g, (_, char) => (char ? char.toUpperCase() : ''))
    .replace(/^./, char => char.toLowerCase())
}

function getTypeScriptType(variable: SafenvVariable): string {
  switch (variable.type) {
    case 'string':
      return 'string'
    case 'number':
      return 'number'
    case 'boolean':
      return 'boolean'
    case 'array':
      return 'string[]'
    case 'object':
      return 'Record<string, unknown>'
    default:
      return 'string'
  }
}

function getZodType(variable: SafenvVariable): string {
  switch (variable.type) {
    case 'string':
      return 'string()'
    case 'number':
      return 'string().transform(Number)'
    case 'boolean':
      return 'string().transform(val => val === "true")'
    case 'array':
      return 'string().transform(val => val.split(",").map(s => s.trim()))'
    case 'object':
      return 'string().transform(val => JSON.parse(val))'
    default:
      return 'string()'
  }
}

function generatePureValidationFunctions(
  _variables: Record<string, SafenvVariable>
): string {
  return `// Pure validation functions
const parseString = (value: unknown): string => String(value)
const parseNumber = (value: unknown): number => {
  const num = Number(value)
  if (isNaN(num)) throw new Error(\`Invalid number: \${value}\`)
  return num
}
const parseBoolean = (value: unknown): boolean => String(value) === 'true'
const parseArray = (value: unknown): string[] => String(value).split(',').map(s => s.trim())
const parseObject = (value: unknown): Record<string, unknown> => JSON.parse(String(value))`
}

function generatePureValidationLogic(
  variables: Record<string, SafenvVariable>
): string {
  const validationSteps: string[] = []

  Object.entries(variables).forEach(([key, variable]) => {
    const parser = `parse${variable.type?.charAt(0).toUpperCase()}${variable.type?.slice(1) || 'String'}`

    validationSteps.push(`    // Validate ${key}`)
    validationSteps.push(`    try {`)
    validationSteps.push(`      const value = input[${JSON.stringify(key)}]`)

    if (variable.required) {
      validationSteps.push(`      if (value === undefined || value === null) {`)
      validationSteps.push(
        `        errors.push('Required field ${key} is missing')`
      )
      validationSteps.push(`      } else {`)
      validationSteps.push(`        result.${key} = ${parser}(value)`)
      validationSteps.push(`      }`)
    } else {
      validationSteps.push(`      if (value !== undefined && value !== null) {`)
      validationSteps.push(`        result.${key} = ${parser}(value)`)
      validationSteps.push(`      }`)
      if (variable.default !== undefined) {
        validationSteps.push(`      else {`)
        validationSteps.push(
          `        result.${key} = ${JSON.stringify(variable.default)}`
        )
        validationSteps.push(`      }`)
      }
    }

    validationSteps.push(`    } catch (err) {`)
    validationSteps.push(
      `      errors.push(\`Failed to parse ${key}: \${err.message}\`)`
    )
    validationSteps.push(`    }`)
    validationSteps.push('')
  })

  return validationSteps.join('\n')
}
